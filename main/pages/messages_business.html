<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Messages - Business Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/messages.css">
</head>
<body>
    <div id="app">
        <!-- Navigation -->
        <nav class="navbar navbar-expand-lg navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="index.html">
                    <i class="fas fa-leaf me-2"></i>Green Business Directory
                </a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav me-auto">
                        <li class="nav-item"><a class="nav-link active" href="partner_dashboard.html">Dashboard</a></li>
                        <li class="nav-item"><a class="nav-link" href="messages_business.html">Messages</a></li>
                    </ul>
                    
                    <div class="auth-block">
                        <div class="dropdown">
                            <button class="btn btn-light btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                <i class="fas fa-user-circle me-1"></i>{{ businessName || userName || 'Business' }}
                            </button>
                            <ul class="dropdown-menu dropdown-menu-end">
                                <li>
                                    <a 
                                        class="dropdown-item" 
                                        href="#"
                                        @click="viewPublicProfile"
                                    >
                                    <i class="fas fa-eye me-2"></i>View Public Profile
                                    </a>
                                </li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="#" @click.prevent="logout">
                                    <i class="fas fa-sign-out-alt me-2"></i>Logout
                                </a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </nav>

        <div class="messaging-container">
            <template v-if="!authInitialized">
                <div class="text-center p-5">
                    <div class="spinner-border text-success" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-3">Checking authentication...</p>
                </div>
            </template>

            <template v-else-if="!isLoggedIn || !isBusinessPartner">
                <div class="container text-center py-5">
                    <h2 class="mb-4">Access Denied</h2>
                    <p class="mb-4">You must be logged in as a business to access this page.</p>
                    <a href="login_business.html" class="btn btn-success btn-lg">
                        <i class="fas fa-sign-in-alt me-2"></i>Business Login
                    </a>
                </div>
            </template>

            <template v-else-if="!currentUserId && !loadingConversations">
                <div class="text-center p-5">
                    <div class="spinner-border text-success" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-3">Initializing messages...</p>
                </div>
            </template>
            
            <template v-else-if="loadingConversations && currentUserId">
                <div class="text-center p-5">
                    <div class="spinner-border text-success" role="status">
                        <span class="visually-hidden">Loading conversations...</span>
                    </div>
                    <p class="mt-3">Loading conversations...</p>
                </div>
            </template>

            <template v-else-if="currentUserId && !loadingConversations">
                <div class="messaging-wrapper">
                    <!-- Conversations Sidebar -->
                    <div class="conversations-sidebar" :class="{'hidden': showChat}">
                        <div class="conversations-header">
                            <h3><i class="fas fa-comments me-2"></i>Customer Messages</h3>
                            <div class="search-box">
                                <input 
                                    type="text" 
                                    class="form-control" 
                                    placeholder="Search conversations..."
                                    v-model="searchQuery"
                                >
                            </div>
                        </div>
                        
                        <div class="conversations-list">
                            <div v-if="loadingConversations" class="text-center p-4">
                                <div class="spinner-border text-success" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                            </div>
                            <div v-else-if="filteredConversations.length === 0" class="text-center p-4 text-muted">
                                <i class="fas fa-inbox fa-2x mb-2"></i>
                                <p>No customer messages yet</p>
                            </div>
                            <div 
                                v-else
                                v-for="conv in filteredConversations" 
                                :key="conv.id"
                                class="conversation-item"
                                :class="{'active': selectedConversation && selectedConversation.id === conv.id}"
                                @click="selectConversation(conv)"
                            >
                                <div class="conversation-avatar">
                                    {{ getInitials(conv.customerName) }}
                                </div>
                                <div class="conversation-content">
                                    <div class="conversation-top">
                                        <span class="conversation-name">{{ conv.customerName }}</span>
                                        <span class="conversation-time">{{ formatTime(conv.lastMessageTime) }}</span>
                                    </div>
                                    <div class="conversation-preview">
                                        <span v-if="conv.unread > 0" class="unread-badge">{{ conv.unread }}</span>
                                        {{ conv.lastMessage }}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Chat Area -->
                    <div class="chat-area" :class="{'mobile-show': showChat}">
                        <div v-if="!selectedConversation" class="empty-state">
                            <i class="fas fa-comments"></i>
                            <h3>Select a conversation</h3>
                            <p>Choose a customer from the list to view messages</p>
                        </div>

                        <template v-else>
                            <!-- Chat Header -->
                            <div class="chat-header">
                                <div class="chat-header-left">
                                    <button class="btn btn-sm btn-link d-md-none me-2 p-1" @click="backToList" style="color: var(--primary-green);">
                                        <i class="fas fa-arrow-left"></i>
                                    </button>
                                    <div class="chat-avatar">
                                        {{ getInitials(selectedConversation.customerName) }}
                                    </div>
                                    <div class="chat-info">
                                        <h4 class="mb-1">{{ selectedConversation.customerName }}</h4>
                                        <span class="status text-muted small" :class="{'online': selectedConversation.online}">
                                            {{ selectedConversation.online ? 'Online' : 'Offline' }}
                                        </span>
                                    </div>
                                </div>
                            </div>

                            <!-- Messages Container -->
                            <div class="messages-container" ref="messagesContainer">
                                <div v-if="loadingMessages" class="text-center p-4">
                                    <div class="spinner-border text-success" role="status">
                                        <span class="visually-hidden">Loading messages...</span>
                                    </div>
                                </div>
                                <template v-else-if="messages.length === 0">
                                    <div class="text-center p-5 text-muted">
                                        <i class="fas fa-comments fa-3x mb-3"></i>
                                        <p>No messages yet. Customer can start the conversation!</p>
                                    </div>
                                </template>
                                <template v-else>
                                    <div v-for="(group, date) in groupedMessages" :key="date">
                                        <div class="message-date">
                                            <span>{{ date }}</span>
                                        </div>
                                        
                                        <div v-for="msg in group" :key="msg.id" class="message" :class="msg.sent ? 'sent' : 'received'">
                                            <div class="message-bubble">
                                                <div class="message-text">{{ msg.text }}</div>
                                                <div class="message-time">{{ msg.time }}</div>
                                            </div>
                                        </div>
                                    </div>
                                </template>
                            </div>

                            <!-- Message Input -->
                            <div class="message-input-area">
                                <div class="message-input-wrapper">
                                    <textarea 
                                        class="message-input" 
                                        placeholder="Type your reply..."
                                        v-model="newMessage"
                                        @keydown.enter.exact.prevent="sendMessage"
                                        @keydown.shift.enter.prevent
                                        rows="1"
                                    ></textarea>
                                    <button 
                                        class="send-button" 
                                        @click="sendMessage"
                                        :disabled="!newMessage.trim() || sendingMessage || !selectedConversation"
                                        title="Send message"
                                    >
                                        <i v-if="!sendingMessage" class="fas fa-paper-plane"></i>
                                        <i v-else class="fas fa-spinner fa-spin"></i>
                                    </button>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
            </template>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script type="module">
    import { authMixin } from './js/auth-mixin.js';
    import { auth, db, firebasePromise } from './js/firebase-config.js';
    import { collection, query, where, orderBy, onSnapshot, addDoc, serverTimestamp, getDocs, getDoc, doc, setDoc } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js";

    const { createApp } = Vue;

    createApp({
        mixins: [authMixin],
        data() {
            return {
                businessName: '',
                businessId: null,
                currentUserId: null,
                mysqlUserId: null,
                searchQuery: '',
                selectedConversation: null,
                newMessage: '',
                showChat: false,
                conversations: [],
                messages: [],
                loadingConversations: true,
                loadingMessages: false,
                sendingMessage: false
            };
        },
        computed: {
            filteredConversations() {
                if (!this.searchQuery) return this.conversations;
                return this.conversations.filter(conv => 
                    conv.customerName.toLowerCase().includes(this.searchQuery.toLowerCase())
                );
            },
            groupedMessages() {
                if (this.messages.length === 0) return {};
                
                const groups = {};
                this.messages.forEach(msg => {
                    const date = this.formatDate(msg.timestamp);
                    if (!groups[date]) {
                        groups[date] = [];
                    }
                    groups[date].push(msg);
                });
                return groups;
            }
        },
        watch: {
            authInitialized(newVal) {
                if (newVal && this.isLoggedIn && this.isBusinessPartner) {
                    this.$nextTick(() => {
                        this.initBusinessMessaging();
                        this.initializeBootstrapDropdowns();
                    });
                } else if (newVal && (!this.isLoggedIn || !this.isBusinessPartner)) {
                    // Auth initialized but user is not a business - redirect
                    window.location.href = 'login_business.html';
                }
            },
            isLoggedIn(newVal) {
                if (newVal && this.isBusinessPartner && this.authInitialized) {
                    this.$nextTick(() => {
                        this.initBusinessMessaging();
                        this.initializeBootstrapDropdowns();
                    });
                }
            },
            businessId(newVal) {
                if (newVal && this.isLoggedIn && this.isBusinessPartner) {
                    this.loadConversations();
                }
            },
            businessName() {
                // Re-initialize dropdowns when business name loads
                this.$nextTick(() => {
                    this.initializeBootstrapDropdowns();
                });
            }
        },
        async mounted() {
            // Wait for auth to initialize
            await firebasePromise;
            
            // Initialize Bootstrap dropdowns after DOM is ready
            this.$nextTick(() => {
                this.initializeBootstrapDropdowns();
            });
            
            // Wait for authMixin to initialize (check every 200ms for up to 5 seconds)
            let attempts = 0;
            const maxAttempts = 25; // 5 seconds total
            const checkAuthAndLoad = () => {
                if (this.authInitialized) {
                    if (this.isLoggedIn && this.isBusinessPartner) {
                        this.initBusinessMessaging();
                        // Re-initialize dropdowns after auth loads
                        this.$nextTick(() => {
                            this.initializeBootstrapDropdowns();
                        });
                    } else {
                        window.location.href = 'login_business.html';
                    }
                } else if (attempts < maxAttempts) {
                    attempts++;
                    setTimeout(checkAuthAndLoad, 200);
                } else {
                    // Timeout - redirect to login
                    console.error('Auth initialization timeout');
                    window.location.href = 'login_business.html';
                }
            };
            
            checkAuthAndLoad();
        },
        methods: {
            initializeBootstrapDropdowns() {
                // Initialize Bootstrap dropdowns manually after Vue renders
                this.$nextTick(() => {
                    // Wait a bit to ensure DOM is fully updated
                    setTimeout(() => {
                        // Try both possible Bootstrap namespaces
                        const Bootstrap = window.bootstrap?.Dropdown || window.Bootstrap?.Dropdown;
                        
                        if (Bootstrap) {
                            // Find all dropdown toggles and initialize them
                            const dropdownElementList = document.querySelectorAll('[data-bs-toggle="dropdown"]');
                            dropdownElementList.forEach(dropdownToggleEl => {
                                // Check if already initialized
                                const existingInstance = Bootstrap.getInstance(dropdownToggleEl);
                                if (!existingInstance) {
                                    try {
                                        new Bootstrap(dropdownToggleEl);
                                    } catch (e) {
                                        console.warn('Failed to initialize dropdown:', e);
                                    }
                                }
                            });
                        } else {
                            console.warn('Bootstrap Dropdown not found. Make sure Bootstrap JS is loaded.');
                        }
                    }, 100);
                });
            },
            async initBusinessMessaging() {
                // Wait for auth to be fully initialized
                if (!this.authInitialized) {
                    console.log('Waiting for auth initialization...');
                    // Wait up to 2 seconds for auth to initialize
                    for (let i = 0; i < 20; i++) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        if (this.authInitialized) break;
                    }
                }
                
                if (!this.isLoggedIn || !this.isBusinessPartner) {
                    console.log('Not logged in or not a business partner', {
                        isLoggedIn: this.isLoggedIn,
                        isBusinessPartner: this.isBusinessPartner,
                        authInitialized: this.authInitialized,
                        userType: this.userType
                    });
                    window.location.href = 'login_business.html';
                    return;
                }
                
                // Wait for Firebase
                await firebasePromise;
                
                if (!auth.currentUser) {
                    window.location.href = 'login_business.html';
                    return;
                }
                
                this.currentUserId = auth.currentUser.uid;
                
                // Get MySQL user ID and business ID from session
                try {
                    const sessionResp = await fetch('api/bridge.php?action=get_user', {
                        credentials: 'include'
                    });
                    
                    if (sessionResp.ok) {
                        const sessionData = await sessionResp.json();
                        if (sessionData.success && sessionData.user?.userType === 'business') {
                            this.mysqlUserId = String(sessionData.user.userId);
                            this.businessId = sessionData.business?.businessId || null;
                            this.businessName = this.userName || 'Business';
                            
                            if (this.businessId) {
                                this.loadConversations();
                            } else {
                                // Wait for businessId to be loaded
                                this.loadBusinessData();
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error getting session:', error);
                }
            },
            
            async loadBusinessData() {
                try {
                    const response = await fetch('api/data.php?action=business_profile', {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.businessId) {
                            this.businessId = parseInt(data.businessId);
                            this.businessName = data.business.business_name || this.userName || 'Business';
                            
                            // After loading business data, load conversations
                            if (this.mysqlUserId) {
                                this.loadConversations();
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error loading business data:', error);
                }
            },
            
            async loadConversations() {
                if (!this.mysqlUserId) return;
                
                this.loadingConversations = true;
                
                try {
                    const conversationsRef = collection(db, "conversations");
                    const q = query(
                        conversationsRef,
                        where("participants", "array-contains", this.mysqlUserId)
                    );
                    
                    const timeoutId = setTimeout(() => {
                        if (this.loadingConversations) {
                            this.conversations = [];
                            this.loadingConversations = false;
                        }
                    }, 8000);
                    
                    const unsubscribe = onSnapshot(q, 
                        async (snapshot) => {
                            clearTimeout(timeoutId);
                            
                            const conversationsList = [];
                            const customerIds = [];
                            
                            // Collect customer IDs (as strings for consistent comparison)
                            snapshot.forEach((docSnap) => {
                                const data = docSnap.data();
                                const participants = data.participants || [];
                                const otherParticipantId = participants.find(id => String(id) !== String(this.mysqlUserId));
                                if (otherParticipantId && !customerIds.includes(String(otherParticipantId))) {
                                    customerIds.push(String(otherParticipantId));
                                }
                            });
                            
                            // Batch fetch customer names
                            const customerNames = await this.getCustomerNamesBatch(customerIds);
                            
                            // Build conversations list
                            snapshot.forEach((docSnap) => {
                                const data = docSnap.data();
                                const participants = data.participants || [];
                                const customerId = participants.find(id => String(id) !== String(this.mysqlUserId));
                                
                                // Handle Firestore timestamp for lastMessageTime
                                let lastMessageTime = new Date();
                                if (data.lastMessageTime) {
                                    if (data.lastMessageTime.toDate && typeof data.lastMessageTime.toDate === 'function') {
                                        lastMessageTime = data.lastMessageTime.toDate();
                                    } else if (data.lastMessageTime instanceof Date) {
                                        lastMessageTime = data.lastMessageTime;
                                    } else if (data.lastMessageTime.seconds) {
                                        lastMessageTime = new Date(data.lastMessageTime.seconds * 1000);
                                    }
                                }
                                
                                conversationsList.push({
                                    id: docSnap.id,
                                    customerId: customerId,
                                    customerName: customerNames[String(customerId)] || 'Customer',
                                    lastMessage: data.lastMessage || '',
                                    lastMessageTime: lastMessageTime,
                                    unread: data.unreadCounts?.[String(this.mysqlUserId)] || 0,
                                    online: false,
                                    participants: participants
                                });
                            });
                            
                            // Sort by last message time
                            conversationsList.sort((a, b) => {
                                const timeA = a.lastMessageTime instanceof Date ? a.lastMessageTime : new Date(0);
                                const timeB = b.lastMessageTime instanceof Date ? b.lastMessageTime : new Date(0);
                                return timeB - timeA;
                            });
                            
                            this.conversations = conversationsList;
                            this.loadingConversations = false;
                        },
                        (error) => {
                            clearTimeout(timeoutId);
                            console.error('Firestore snapshot error:', error);
                            this.conversations = [];
                            this.loadingConversations = false;
                        }
                    );
                } catch (error) {
                    console.error('Error loading conversations:', error);
                    this.loadingConversations = false;
                }
            },
            
            async getCustomerNamesBatch(customerIds) {
                const names = {};
                if (!customerIds || customerIds.length === 0) return names;
                
                try {
                    // Get customer names from MySQL users table - batch request
                    const response = await fetch(`api/data.php?action=get_user_names_batch`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ user_ids: customerIds })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.names) {
                            Object.assign(names, data.names);
                        }
                    }
                    
                    // Fallback for any missing names
                    customerIds.forEach(id => {
                        if (!names[id]) {
                            names[id] = 'Customer';
                        }
                    });
                } catch (error) {
                    console.error('Error batch fetching customer names:', error);
                    // Fallback: set all to 'Customer'
                    customerIds.forEach(id => {
                        names[id] = 'Customer';
                    });
                }
                
                return names;
            },
            
            async selectConversation(conv) {
                this.selectedConversation = conv;
                conv.unread = 0;
                this.showChat = true;
                
                if (conv.id) {
                    this.loadMessages(conv.id);
                }
                
                this.$nextTick(() => {
                    this.scrollToBottom();
                });
            },
            
            async loadMessages(conversationId) {
                if (!conversationId) return;
                
                this.loadingMessages = true;
                this.messages = [];
                
                try {
                    const messagesRef = collection(db, "conversations", conversationId, "messages");
                    const q = query(messagesRef, orderBy("timestamp", "asc"));
                    
                    onSnapshot(q, (snapshot) => {
                        this.messages = [];
                        snapshot.forEach((docSnap) => {
                            const data = docSnap.data();
                            // Business sent the message if senderId matches mysqlUserId (compare as strings)
                            const isSent = this.mysqlUserId && String(data.senderId) === String(this.mysqlUserId);
                            
                            // Handle Firestore timestamp
                            let timestamp = new Date();
                            if (data.timestamp) {
                                if (data.timestamp.toDate && typeof data.timestamp.toDate === 'function') {
                                    timestamp = data.timestamp.toDate();
                                } else if (data.timestamp instanceof Date) {
                                    timestamp = data.timestamp;
                                } else if (data.timestamp.seconds) {
                                    timestamp = new Date(data.timestamp.seconds * 1000);
                                }
                            }
                            
                            this.messages.push({
                                id: docSnap.id,
                                text: data.text || '',
                                senderId: data.senderId,
                                sent: isSent,
                                timestamp: timestamp,
                                time: this.formatTime(timestamp)
                            });
                        });
                        this.loadingMessages = false;
                        this.$nextTick(() => {
                            this.scrollToBottom();
                        });
                    }, (error) => {
                        console.error('Error in messages snapshot:', error);
                        this.loadingMessages = false;
                    });
                } catch (error) {
                    console.error('Error loading messages:', error);
                    this.loadingMessages = false;
                }
            },
            
             async sendMessage() {
                 if (!this.newMessage.trim() || !this.selectedConversation || this.sendingMessage) return;
                 if (!this.mysqlUserId) {
                     alert('Error: Could not identify user. Please refresh the page.');
                     return;
                 }
                 
                 this.sendingMessage = true;
                 
                 try {
                     const conversationId = this.selectedConversation.id;
                     const messageText = this.newMessage.trim();
                     
                     const messagesRef = collection(db, "conversations", conversationId, "messages");
                     await addDoc(messagesRef, {
                         text: messageText,
                         senderId: String(this.mysqlUserId), // Use MySQL user ID as string for consistency
                         timestamp: serverTimestamp()
                     });
                     
                     const conversationRef = doc(db, "conversations", conversationId);
                     const customerId = this.selectedConversation.customerId;
                     const participants = this.selectedConversation.participants || [String(this.mysqlUserId), String(customerId)];
                     
                     // Get conversation data for unread counts
                     const convDoc = await getDoc(conversationRef);
                     const convData = convDoc.exists() ? convDoc.data() : {};
                     const currentUnreadCounts = convData.unreadCounts || {};
                     
                     await setDoc(conversationRef, {
                         lastMessage: messageText,
                         lastMessageTime: serverTimestamp(),
                         participants: participants,
                         unreadCounts: {
                             [String(this.mysqlUserId)]: 0,
                             [String(customerId)]: (parseInt(currentUnreadCounts[String(customerId)]) || 0) + 1
                         }
                     }, { merge: true });
                     
                     this.newMessage = '';
                     this.$nextTick(() => {
                         this.scrollToBottom();
                     });
                 } catch (error) {
                     console.error('Error sending message:', error);
                     alert('Error sending message: ' + (error.message || 'Please try again.'));
                 } finally {
                     this.sendingMessage = false;
                 }
             },
            
            async viewPublicProfile() {
                if (!this.businessId) {
                    alert('Business ID not available. Please refresh the page.');
                    return;
                }
                window.location.href = `business_profile.html?id=${this.businessId}`;
            },
            
            backToList() {
                this.showChat = false;
            },
            
            scrollToBottom() {
                const container = this.$refs.messagesContainer;
                if (container) {
                    container.scrollTop = container.scrollHeight;
                }
            },
            
            getInitials(name) {
                if (!name) return '?';
                const parts = name.split(' ');
                if (parts.length > 1) {
                    return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                }
                return name[0].toUpperCase();
            },
            
            formatTime(date) {
                if (!date) return '';
                // Handle Firestore Timestamp objects
                const d = date && typeof date.toDate === 'function' ? date.toDate() : (date instanceof Date ? date : new Date(date));
                const now = new Date();
                const diff = Math.floor((now - d) / 1000);
                
                if (diff < 60) return 'Just now';
                if (diff < 3600) return Math.floor(diff / 60) + 'm ago';
                if (diff < 86400) return Math.floor(diff / 3600) + 'h ago';
                return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            },
            
            formatDate(date) {
                if (!date) return '';
                // Handle Firestore Timestamp objects
                const d = date && typeof date.toDate === 'function' ? date.toDate() : (date instanceof Date ? date : new Date(date));
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                if (d.toDateString() === today.toDateString()) return 'Today';
                if (d.toDateString() === yesterday.toDateString()) return 'Yesterday';
                return d.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
            }
        }
    }).mount('#app');
    </script>
</body>
</html>
