<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Messages - Business Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/messages.css">
</head>
<body>
    <div id="app">
        <!-- Navigation -->
        <nav class="navbar navbar-expand-lg navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="index.html">
                    <i class="fas fa-leaf me-2"></i>Green Business Directory
                </a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav me-auto">
                        <li class="nav-item"><a class="nav-link" href="partner_dashboard.html">Dashboard</a></li>
                        <li class="nav-item"><a class="nav-link" href="messages_business.html">Messages</a></li>
                    </ul>
                    
                    <div class="auth-block">
                        <div class="dropdown">
                            <button class="btn btn-light btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                <i class="fas fa-user-circle me-1"></i>{{ businessName || userName || 'Business' }}
                            </button>
                            <ul class="dropdown-menu dropdown-menu-end">
                                <li>
                                    <a 
                                        class="dropdown-item" 
                                        href="#"
                                        @click="viewPublicProfile"
                                    >
                                    <i class="fas fa-eye me-2"></i>View Public Profile
                                    </a>
                                </li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="#" @click.prevent="logout">
                                    <i class="fas fa-sign-out-alt me-2"></i>Logout
                                </a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </nav>

        <div class="messaging-container">
            <template v-if="!authInitialized">
                <div class="text-center p-5">
                    <div class="spinner-border text-success" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-3">Checking authentication...</p>
                </div>
            </template>

            <template v-else-if="!isLoggedIn || !isBusinessPartner">
                <div class="container text-center py-5">
                    <h2 class="mb-4">Access Denied</h2>
                    <p class="mb-4">You must be logged in as a business to access this page.</p>
                    <a href="login_business.html" class="btn btn-success btn-lg">
                        <i class="fas fa-sign-in-alt me-2"></i>Business Login
                    </a>
                </div>
            </template>

            <template v-else-if="!currentUserId && !loadingConversations">
                <div class="text-center p-5">
                    <div class="spinner-border text-success" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-3">Initializing messages...</p>
                </div>
            </template>
            
            <template v-else-if="loadingConversations && currentUserId">
                <div class="text-center p-5">
                    <div class="spinner-border text-success" role="status">
                        <span class="visually-hidden">Loading conversations...</span>
                    </div>
                    <p class="mt-3">Loading conversations...</p>
                </div>
            </template>

            <template v-else-if="currentUserId && !loadingConversations">
                <div class="messaging-wrapper">
                    <!-- Conversations Sidebar -->
                    <div class="conversations-sidebar" :class="{'hidden': showChat}">
                        <div class="conversations-header">
                            <h3><i class="fas fa-comments me-2"></i>Customer Messages</h3>
                            <div class="search-box">
                                <input 
                                    type="text" 
                                    class="form-control" 
                                    placeholder="Search conversations..."
                                    v-model="searchQuery"
                                >
                            </div>
                        </div>
                        
                        <div class="conversations-list">
                            <div v-if="loadingConversations" class="text-center p-4">
                                <div class="spinner-border text-success" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                            </div>
                            <div v-else-if="filteredConversations.length === 0" class="text-center p-4 text-muted">
                                <i class="fas fa-inbox fa-2x mb-2"></i>
                                <p>No customer messages yet</p>
                            </div>
                            <div 
                                v-else
                                v-for="conv in filteredConversations" 
                                :key="conv.id"
                                class="conversation-item"
                                :class="{'active': selectedConversation && selectedConversation.id === conv.id}"
                                @click="selectConversation(conv)"
                            >
                                <div class="conversation-avatar">
                                    {{ getInitials(conv.customerName) }}
                                </div>
                                <div class="conversation-content">
                                    <div class="conversation-top">
                                        <span class="conversation-name">{{ conv.customerName }}</span>
                                        <span class="conversation-time">{{ formatTime(conv.lastMessageTime) }}</span>
                                    </div>
                                    <div class="conversation-preview">
                                        <span v-if="conv.unread > 0" class="unread-badge">{{ conv.unread }}</span>
                                        {{ conv.lastMessage }}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Chat Area -->
                    <div class="chat-area" :class="{'mobile-show': showChat}">
                        <div v-if="!selectedConversation" class="empty-state">
                            <i class="fas fa-comments"></i>
                            <h3>Select a conversation</h3>
                            <p>Choose a customer from the list to view messages</p>
                        </div>

                        <template v-else>
                            <!-- Chat Header -->
                            <div class="chat-header">
                                <div class="chat-header-left">
                                    <button class="btn btn-sm btn-link d-md-none me-2 p-1" @click="backToList" style="color: var(--primary-green);">
                                        <i class="fas fa-arrow-left"></i>
                                    </button>
                                    <div class="chat-avatar">
                                        {{ getInitials(selectedConversation.customerName) }}
                                    </div>
                                    <div class="chat-info">
                                        <h4 class="mb-1">{{ selectedConversation.customerName }}</h4>
                                        <span class="status text-muted small" :class="{'online': selectedConversation.online}">
                                            {{ selectedConversation.online ? 'Online' : 'Offline' }}
                                        </span>
                                    </div>
                                </div>
                            </div>

                            <!-- Messages Container -->
                            <div class="messages-container" ref="messagesContainer">
                                <div v-if="loadingMessages" class="text-center p-4">
                                    <div class="spinner-border text-success" role="status">
                                        <span class="visually-hidden">Loading messages...</span>
                                    </div>
                                </div>
                                <template v-else-if="messages.length === 0">
                                    <div class="text-center p-5 text-muted">
                                        <i class="fas fa-comments fa-3x mb-3"></i>
                                        <p>No messages yet. Customer can start the conversation!</p>
                                    </div>
                                </template>
                                <template v-else>
                                    <div v-for="(group, date) in groupedMessages" :key="date">
                                        <div class="message-date">
                                            <span>{{ date }}</span>
                                        </div>
                                        
                                        <div v-for="msg in group" :key="msg.id" class="message" :class="msg.sent ? 'sent' : 'received'">
                                            <div class="message-bubble">
                                                <div class="message-text">{{ msg.text }}</div>
                                                <div class="message-time">{{ msg.time }}</div>
                                            </div>
                                        </div>
                                    </div>
                                </template>
                            </div>

                            <!-- Message Input -->
                            <div class="message-input-area">
                                <div class="message-input-wrapper">
                                    <textarea 
                                        class="message-input" 
                                        placeholder="Type your reply..."
                                        v-model="newMessage"
                                        @keydown.enter.exact.prevent="sendMessage"
                                        @keydown.shift.enter.prevent
                                        rows="1"
                                    ></textarea>
                                    <button 
                                        class="send-button" 
                                        @click="sendMessage"
                                        :disabled="!newMessage.trim() || sendingMessage || !selectedConversation"
                                        title="Send message"
                                    >
                                        <i v-if="!sendingMessage" class="fas fa-paper-plane"></i>
                                        <i v-else class="fas fa-spinner fa-spin"></i>
                                    </button>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
            </template>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script type="module">
    import { authMixin } from './js/auth-mixin.js';
    // Firebase completely removed - using PHP/MySQL for messaging

    const { createApp } = Vue;

    createApp({
        mixins: [authMixin],
        data() {
            return {
                businessName: '',
                businessId: null,
                currentUserId: null,
                mysqlUserId: null,
                searchQuery: '',
                selectedConversation: null,
                newMessage: '',
                showChat: false,
                conversations: [],
                messages: [],
                loadingConversations: true,
                loadingMessages: false,
                sendingMessage: false,
                pollingInterval: null,
                messagesPollingInterval: null,
                lastMessageId: null
            };
        },
        computed: {
            filteredConversations() {
                if (!this.searchQuery) return this.conversations;
                return this.conversations.filter(conv => 
                    conv.customerName.toLowerCase().includes(this.searchQuery.toLowerCase())
                );
            },
            groupedMessages() {
                if (this.messages.length === 0) return {};
                
                const groups = {};
                this.messages.forEach(msg => {
                    const date = this.formatDate(msg.timestamp);
                    if (!groups[date]) {
                        groups[date] = [];
                    }
                    groups[date].push(msg);
                });
                return groups;
            }
        },
        watch: {
            authInitialized(newVal) {
                if (newVal && this.isLoggedIn && this.isBusinessPartner) {
                    this.$nextTick(() => {
                        this.initBusinessMessaging();
                        this.initializeBootstrapDropdowns();
                    });
                } else if (newVal && (!this.isLoggedIn || !this.isBusinessPartner)) {
                    // Auth initialized but user is not a business - redirect
                    window.location.href = 'login_business.html';
                }
            },
            isLoggedIn(newVal) {
                if (newVal && this.isBusinessPartner && this.authInitialized) {
                    this.$nextTick(() => {
                        this.initBusinessMessaging();
                        this.initializeBootstrapDropdowns();
                    });
                }
            },
            businessId(newVal) {
                if (newVal && this.isLoggedIn && this.isBusinessPartner) {
                    this.loadConversations(true);
                }
            },
            businessName() {
                // Re-initialize dropdowns when business name loads
                this.$nextTick(() => {
                    this.initializeBootstrapDropdowns();
                });
            }
        },
        async mounted() {
            // Wait for auth to initialize
            await initFirestore();
            
            // Initialize Bootstrap dropdowns after DOM is ready
            this.$nextTick(() => {
                this.initializeBootstrapDropdowns();
            });
            
            // Wait for authMixin to initialize (check every 200ms for up to 5 seconds)
            let attempts = 0;
            const maxAttempts = 25; // 5 seconds total
            const checkAuthAndLoad = () => {
                if (this.authInitialized) {
                    if (this.isLoggedIn && this.isBusinessPartner) {
                        this.initBusinessMessaging();
                        // Re-initialize dropdowns after auth loads
                        this.$nextTick(() => {
                            this.initializeBootstrapDropdowns();
                        });
                    } else {
                        window.location.href = 'login_business.html';
                    }
                } else if (attempts < maxAttempts) {
                    attempts++;
                    setTimeout(checkAuthAndLoad, 200);
                } else {
                    // Timeout - redirect to login
                    console.error('Auth initialization timeout');
                    window.location.href = 'login_business.html';
                }
            };
            
            checkAuthAndLoad();
        },
        methods: {
            initializeBootstrapDropdowns() {
                // Initialize Bootstrap dropdowns manually after Vue renders
                this.$nextTick(() => {
                    // Wait a bit to ensure DOM is fully updated
                    setTimeout(() => {
                        // Try both possible Bootstrap namespaces
                        const Bootstrap = window.bootstrap?.Dropdown || window.Bootstrap?.Dropdown;
                        
                        if (Bootstrap) {
                            // Find all dropdown toggles and initialize them
                            const dropdownElementList = document.querySelectorAll('[data-bs-toggle="dropdown"]');
                            dropdownElementList.forEach(dropdownToggleEl => {
                                // Check if already initialized
                                const existingInstance = Bootstrap.getInstance(dropdownToggleEl);
                                if (!existingInstance) {
                                    try {
                                        new Bootstrap(dropdownToggleEl);
                                    } catch (e) {
                                        console.warn('Failed to initialize dropdown:', e);
                                    }
                                }
                            });
                        } else {
                            console.warn('Bootstrap Dropdown not found. Make sure Bootstrap JS is loaded.');
                        }
                    }, 100);
                });
            },
            async initBusinessMessaging() {
                // Wait for auth to be fully initialized
                if (!this.authInitialized) {
                    console.log('Waiting for auth initialization...');
                    // Wait up to 2 seconds for auth to initialize
                    for (let i = 0; i < 20; i++) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        if (this.authInitialized) break;
                    }
                }
                
                if (!this.isLoggedIn || !this.isBusinessPartner) {
                    console.log('Not logged in or not a business partner', {
                        isLoggedIn: this.isLoggedIn,
                        isBusinessPartner: this.isBusinessPartner,
                        authInitialized: this.authInitialized,
                        userType: this.userType
                    });
                    window.location.href = 'login_business.html';
                    return;
                }
                
                // Use MySQL session - no Firebase needed
                // Check if user is logged in via session
                if (!this.isLoggedIn || !this.userId) {
                    window.location.href = 'login_business.html';
                    return;
                }
                
                this.currentUserId = this.userId.toString(); // Use MySQL user ID
                
                // Get MySQL user ID and business ID from session
                try {
                    const sessionResp = await fetch('api/bridge.php?action=get_user', {
                        credentials: 'include'
                    });
                    
                    if (sessionResp.ok) {
                        const sessionData = await sessionResp.json();
                        if (sessionData.success && sessionData.user?.userType === 'business') {
                            this.mysqlUserId = String(sessionData.user.userId);
                            this.businessId = sessionData.business?.businessId || null;
                            this.businessName = this.userName || 'Business';
                            
                            if (this.businessId) {
                                this.loadConversations(true);
                            } else {
                                // Wait for businessId to be loaded
                                this.loadBusinessData();
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error getting session:', error);
                }
            },
            
            async loadBusinessData() {
                try {
                    const response = await fetch('api/data.php?action=business_profile', {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.businessId) {
                            this.businessId = parseInt(data.businessId);
                            this.businessName = data.business.business_name || this.userName || 'Business';
                            
                            // After loading business data, load conversations
                            if (this.mysqlUserId) {
                                this.loadConversations(true);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error loading business data:', error);
                }
            },
            
            async loadConversations(showLoading = false) {
                if (!this.mysqlUserId) return;
                
                // Only show loading spinner on initial load, not during polling
                if (showLoading) {
                    this.loadingConversations = true;
                }
                
                try {
                    const response = await fetch('api/messages.php?action=conversations', {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    if (!response.ok) {
                        if (response.status === 401) {
                            alert('Session expired. Please log in again.');
                            window.location.href = 'login_business.html';
                            return;
                        }
                        throw new Error('Failed to load conversations');
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        const newConversations = data.conversations.map(conv => {
                            // Fix timestamp year before storing
                            let lastMessageTime = conv.last_message_time || null;
                            if (lastMessageTime && typeof lastMessageTime === 'string' && lastMessageTime.startsWith('2025-')) {
                                lastMessageTime = lastMessageTime.replace('2025-', '2024-');
                            }
                            
                            return {
                                id: conv.id,
                                consumer_id: conv.consumer_id,
                                customerId: conv.consumer_id,
                                customerName: conv.customer_name || 'Customer',
                                lastMessage: conv.last_message || '',
                                lastMessageTime: lastMessageTime,
                                unread: conv.unread_count || 0
                            };
                        });
                        
                        // Create a map of existing conversations by ID for efficient lookup
                        const existingMap = new Map();
                        this.conversations.forEach(conv => {
                            existingMap.set(conv.id, conv);
                        });
                        
                        // Check if conversations actually changed by comparing by ID
                        let hasChanged = false;
                        const newMap = new Map();
                        newConversations.forEach(newConv => {
                            newMap.set(newConv.id, newConv);
                            const oldConv = existingMap.get(newConv.id);
                            if (!oldConv || 
                                oldConv.lastMessage !== newConv.lastMessage ||
                                oldConv.lastMessageTime !== newConv.lastMessageTime ||
                                oldConv.unread !== newConv.unread ||
                                oldConv.customerName !== newConv.customerName) {
                                hasChanged = true;
                            }
                        });
                        
                        // Check if any conversations were removed
                        if (this.conversations.length !== newConversations.length) {
                            hasChanged = true;
                        }
                        
                        // Only update if something changed
                        if (hasChanged || this.conversations.length === 0) {
                            // Update existing conversations in place to preserve Vue reactivity
                            if (this.conversations.length > 0) {
                                newConversations.forEach(newConv => {
                                    const existing = existingMap.get(newConv.id);
                                    if (existing) {
                                        // Update in place
                                        existing.lastMessage = newConv.lastMessage;
                                        existing.lastMessageTime = newConv.lastMessageTime;
                                        existing.unread = newConv.unread;
                                        existing.customerName = newConv.customerName;
                                    } else {
                                        // New conversation - add it
                                        this.conversations.push(newConv);
                                    }
                                });
                                
                                // Remove conversations that no longer exist
                                this.conversations = this.conversations.filter(conv => newMap.has(conv.id));
                            } else {
                                // First load - just set the array
                                this.conversations = newConversations;
                            }
                            
                            // Sort by last message time (newest first)
                            this.conversations.sort((a, b) => {
                                const timeA = a.lastMessageTime ? new Date(a.lastMessageTime.replace('2025-', '2024-')) : new Date(0);
                                const timeB = b.lastMessageTime ? new Date(b.lastMessageTime.replace('2025-', '2024-')) : new Date(0);
                                return timeB.getTime() - timeA.getTime();
                            });
                        }
                        
                        this.loadingConversations = false;
                        
                        // Start polling for new conversations (only if not already polling)
                        if (!this.pollingInterval) {
                            this.pollingInterval = setInterval(() => this.loadConversations(false), 5000); // Poll every 5 seconds without loading spinner
                        }
                    } else {
                        throw new Error(data.error || 'Failed to load conversations');
                    }
                } catch (error) {
                    console.error('Error loading conversations:', error);
                    this.loadingConversations = false;
                    this.conversations = [];
                }
            },
            
            async selectConversation(conv) {
                this.selectedConversation = conv;
                conv.unread = 0;
                this.showChat = true;
                
                if (conv.id) {
                    this.loadMessages(conv.id);
                }
                
                this.$nextTick(() => {
                    this.scrollToBottom();
                });
            },
            
            async loadMessages(conversationId, preserveScroll = false) {
                if (!conversationId) return;
                
                // Only show loading spinner if not preserving scroll (i.e., not during polling)
                if (!preserveScroll) {
                    this.loadingMessages = true;
                    this.messages = [];
                }
                
                // Stop previous polling
                if (this.messagesPollingInterval) {
                    clearInterval(this.messagesPollingInterval);
                }
                
                try {
                    const response = await fetch(`api/messages.php?action=messages&conversation_id=${conversationId}`, {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to load messages');
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Store current scroll position if preserving
                        let scrollTop = 0;
                        let scrollHeight = 0;
                        const container = this.$refs.messagesContainer;
                        if (preserveScroll && container) {
                            scrollTop = container.scrollTop;
                            scrollHeight = container.scrollHeight;
                        }
                        
                        this.messages = data.messages.map(msg => {
                            // Fix timestamp year before creating Date object
                            let timestampStr = msg.timestamp;
                            if (typeof timestampStr === 'string' && timestampStr.startsWith('2025-')) {
                                timestampStr = timestampStr.replace('2025-', '2024-');
                            }
                            
                            return {
                                id: msg.id,
                                text: msg.text,
                                senderId: msg.sender_id,
                                senderName: msg.sender_name,
                                sent: this.mysqlUserId && msg.sender_id == this.mysqlUserId,
                                timestamp: new Date(timestampStr),
                                time: this.formatTime(timestampStr)
                            };
                        });
                        
                        this.lastMessageId = this.messages.length > 0 ? this.messages[this.messages.length - 1].id : null;
                        this.loadingMessages = false;
                        
                        if (preserveScroll && container) {
                            // Restore scroll position
                            this.$nextTick(() => {
                                const newScrollHeight = container.scrollHeight;
                                const scrollDiff = newScrollHeight - scrollHeight;
                                container.scrollTop = scrollTop + scrollDiff;
                            });
                        } else {
                            // Scroll to bottom on initial load
                            this.$nextTick(() => {
                                this.scrollToBottom();
                            });
                        }
                        
                        // Start polling for new messages
                        this.messagesPollingInterval = setInterval(() => {
                            this.pollMessages(conversationId);
                        }, 3000); // Poll every 3 seconds
                    } else {
                        throw new Error(data.error || 'Failed to load messages');
                    }
                } catch (error) {
                    console.error('Error loading messages:', error);
                    this.loadingMessages = false;
                }
            },
            
            async pollMessages(conversationId) {
                if (!conversationId || !this.selectedConversation || this.selectedConversation.id !== conversationId) {
                    return; // Don't poll if conversation changed
                }
                
                try {
                    const response = await fetch(`api/messages.php?action=messages&conversation_id=${conversationId}`, {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        if (data.success && data.messages.length > 0) {
                            // Check if there are new messages
                            const lastMsg = data.messages[data.messages.length - 1];
                            if (lastMsg.id !== this.lastMessageId) {
                                // Only add new messages instead of reloading everything
                                const existingIds = new Set(this.messages.map(m => m.id));
                                let hasNewMessages = false;
                                
                                data.messages.forEach(msg => {
                                    if (!existingIds.has(msg.id)) {
                                        // Fix timestamp year before creating Date object
                                        let timestampStr = msg.timestamp;
                                        if (typeof timestampStr === 'string' && timestampStr.startsWith('2025-')) {
                                            timestampStr = timestampStr.replace('2025-', '2024-');
                                        }
                                        
                                        const newMsg = {
                                            id: msg.id,
                                            text: msg.text,
                                            senderId: msg.sender_id,
                                            senderName: msg.sender_name,
                                            sent: this.mysqlUserId && msg.sender_id == this.mysqlUserId,
                                            timestamp: new Date(timestampStr),
                                            time: this.formatTime(timestampStr)
                                        };
                                        this.messages.push(newMsg);
                                        hasNewMessages = true;
                                    }
                                });
                                
                                if (hasNewMessages) {
                                    this.lastMessageId = this.messages[this.messages.length - 1].id;
                                    // Scroll to bottom only if user is near bottom (not scrolled up)
                                    const container = this.$refs.messagesContainer;
                                    if (container) {
                                        const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 200;
                                        if (isNearBottom) {
                                            setTimeout(() => {
                                                this.scrollToBottom();
                                            }, 100);
                                        }
                                    }
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error polling messages:', error);
                }
            },
            
            async sendMessage() {
                if (!this.newMessage.trim() || !this.selectedConversation || this.sendingMessage) return;
                if (!this.mysqlUserId) {
                    alert('Error: Could not identify user. Please refresh the page.');
                    return;
                }
                
                this.sendingMessage = true;
                
                try {
                    const conversationId = this.selectedConversation.id;
                    const messageText = this.newMessage.trim();
                    
                    const response = await fetch('api/messages.php?action=send', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            conversation_id: conversationId,
                            text: messageText
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to send message');
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        if (data.message) {
                            // Fix timestamp year before creating Date object
                            let timestampStr = data.message.timestamp;
                            if (typeof timestampStr === 'string' && timestampStr.startsWith('2025-')) {
                                timestampStr = timestampStr.replace('2025-', '2024-');
                            }
                            
                            // Add message to local array immediately for instant feedback
                            const newMsg = {
                                id: data.message.id,
                                text: data.message.text,
                                senderId: data.message.sender_id,
                                senderName: data.message.sender_name,
                                sent: true,
                                timestamp: new Date(timestampStr),
                                time: this.formatTime(timestampStr)
                            };
                            this.messages.push(newMsg);
                            this.lastMessageId = newMsg.id;
                        }
                        
                        // Update conversation list without reloading (to avoid scroll jump and flickering)
                        if (this.selectedConversation && this.selectedConversation.id === data.conversation_id) {
                            // Update last message in current conversation
                            this.selectedConversation.lastMessage = data.message?.text || '';
                            // Fix timestamp year before storing
                            let timestamp = data.message?.timestamp || '';
                            if (timestamp && typeof timestamp === 'string' && timestamp.startsWith('2025-')) {
                                timestamp = timestamp.replace('2025-', '2024-');
                            }
                            this.selectedConversation.lastMessageTime = timestamp;
                            
                            // Update unread count if it's a received message
                            if (data.message && !data.message.sent) {
                                this.selectedConversation.unread = (this.selectedConversation.unread || 0) + 1;
                            }
                        }
                        
                        // Don't reload conversations immediately - let the polling handle it to avoid flickering
                        
                        this.newMessage = '';
                        // Use setTimeout to ensure DOM is updated before scrolling
                        setTimeout(() => {
                            this.scrollToBottom();
                        }, 100);
                    } else {
                        throw new Error(data.error || 'Failed to send message');
                    }
                } catch (error) {
                    console.error('Error sending message:', error);
                    alert('Error sending message: ' + (error.message || 'Please try again.'));
                } finally {
                    this.sendingMessage = false;
                }
            },
            
            beforeUnmount() {
                // Clean up polling intervals
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                }
                if (this.messagesPollingInterval) {
                    clearInterval(this.messagesPollingInterval);
                }
            },
            
            async viewPublicProfile() {
                if (!this.businessId) {
                    alert('Business ID not available. Please refresh the page.');
                    return;
                }
                window.location.href = `business_profile.html?id=${this.businessId}`;
            },
            
            backToList() {
                this.showChat = false;
            },
            
            scrollToBottom() {
                this.$nextTick(() => {
                    setTimeout(() => {
                        const container = this.$refs.messagesContainer;
                        if (container) {
                            // Use scrollTop for reliable scrolling
                            container.scrollTop = container.scrollHeight;
                        }
                    }, 50);
                });
            },
            
            getInitials(name) {
                if (!name) return '?';
                const parts = name.split(' ');
                if (parts.length > 1) {
                    return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                }
                return name[0].toUpperCase();
            },
            
            formatTime(date) {
                if (!date) return '';
                
                // Handle MySQL datetime strings (e.g., "2024-01-15 10:30:00") or Date objects
                let d;
                let originalInput = date;
                
                if (typeof date === 'string') {
                    // MySQL datetime format: "YYYY-MM-DD HH:MM:SS"
                    let normalized = date.trim();
                    
                    // Check if date is in 2025 when we're in 2024 - auto-fix year
                    const currentYear = new Date().getFullYear();
                    if (currentYear === 2024 || currentYear === 2025) {
                        // If timestamp starts with 2025, replace with 2024
                        if (normalized.startsWith('2025-')) {
                            normalized = normalized.replace('2025-', '2024-');
                            console.log('Auto-corrected year from 2025 to 2024:', date, '->', normalized);
                        }
                    }
                    
                    if (normalized.includes(' ') && !normalized.includes('T')) {
                        // Replace space with T for ISO parsing (local time)
                        normalized = normalized.replace(' ', 'T');
                    }
                    d = new Date(normalized);
                } else if (date instanceof Date) {
                    d = new Date(date); // Create a copy to avoid mutating original
                    // Check if date is in 2025 when current year is 2024
                    const currentYear = new Date().getFullYear();
                    if (d.getFullYear() === 2025 && (currentYear === 2024 || currentYear === 2025)) {
                        // Adjust year back by 1
                        d.setFullYear(d.getFullYear() - 1);
                        console.log('Auto-corrected Date object year from 2025 to 2024, original:', date);
                    }
                } else {
                    d = new Date(date);
                }
                
                // Check if date is valid
                if (isNaN(d.getTime())) {
                    console.error('Invalid timestamp:', date);
                    return '';
                }
                
                const now = new Date();
                const diffMs = now.getTime() - d.getTime();
                let diff = Math.floor(diffMs / 1000);
                
                // Handle future dates (might be due to timezone issues or wrong dates)
                if (diff < 0) {
                    // If date is in the future, check if it's a year off (common DB issue)
                    const yearDiff = now.getFullYear() - d.getFullYear();
                    // If date is exactly 1 year ahead (yearDiff === -1), adjust it
                    if (yearDiff === -1 && Math.abs(diff) < 400 * 24 * 3600) { // Within ~400 days
                        // Likely a year off - adjust by subtracting a year
                        d.setFullYear(d.getFullYear() - 1);
                        diff = Math.floor((now.getTime() - d.getTime()) / 1000);
                        console.log('Adjusted future date year, new diff:', diff, 'seconds');
                    } else {
                        console.log('Future date detected, showing Just now. Original:', originalInput, 'Parsed:', d, 'Diff:', diff);
                        return 'Just now'; // Future dates show as "Just now"
                    }
                }
                
                if (diff < 0) return 'Just now';
                if (diff < 60) return 'Just now';
                
                // Get today and yesterday dates using local time
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                // Get message date at midnight for comparison
                const msgDate = new Date(d);
                msgDate.setHours(0, 0, 0, 0);
                
                // Debug: log the comparison
                const isToday = msgDate.getTime() === today.getTime();
                const isYesterday = msgDate.getTime() === yesterday.getTime();
                
                // Check if same day
                if (isToday) {
                    if (diff < 3600) {
                        // Less than 1 hour: show "X min ago"
                        const mins = Math.floor(diff / 60);
                        return mins === 1 ? '1 min ago' : mins + ' min ago';
                    } else {
                        // Same day but > 1 hour: show time like "15:00"
                        return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                    }
                }
                
                // Check if yesterday
                if (isYesterday) {
                    return 'Yesterday ' + d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                }
                
                // For older messages (not today or yesterday)
                if (diff < 604800) {
                    // Within a week: show days ago
                    const days = Math.floor(diff / 86400);
                    if (days === 0) {
                        // Same day but might have failed date comparison due to timezone - show time
                        return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                    } else if (days === 1) {
                        return 'Yesterday';
                    } else {
                        return days + ' days ago';
                    }
                }
                
                // Older than a week: show date
                return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            },
            
            formatDate(date) {
                if (!date) return '';
                
                // Handle MySQL datetime strings
                let d;
                if (typeof date === 'string') {
                    let normalized = date.trim();
                    if (normalized.includes(' ') && !normalized.includes('T')) {
                        normalized = normalized.replace(' ', 'T');
                    }
                    d = new Date(normalized);
                } else if (date instanceof Date) {
                    d = date;
                } else {
                    d = new Date(date);
                }
                
                // Check if date is valid
                if (isNaN(d.getTime())) {
                    return '';
                }
                
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                if (d.toDateString() === today.toDateString()) return 'Today';
                if (d.toDateString() === yesterday.toDateString()) return 'Yesterday';
                return d.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
            }
        }
    }).mount('#app');
    </script>
    <script>
        // Set active nav link based on current page
        document.addEventListener('DOMContentLoaded', function() {
            const currentPage = window.location.pathname.split('/').pop() || 'messages_business.html';
            const navLinks = document.querySelectorAll('.navbar-nav .nav-link');
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                const linkHref = link.getAttribute('href');
                if (linkHref && (linkHref === currentPage || (currentPage === '' && linkHref === 'messages_business.html'))) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>
