<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Messages - Green Business Directory</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/messages.css">
</head>
<body>
    <div id="app">
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="index.html">
                    <i class="fas fa-leaf me-2"></i>Green Business Directory
                </a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav me-auto">
                        <li class="nav-item">
                            <a class="nav-link" href="index.html">Home</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="directory.html">Directory</a>
                        </li>
                        <li class="nav-item"><a class="nav-link" href="forum.html">Community</a></li>
                        <li class="nav-item"><a class="nav-link" href="event.html">Events</a></li>
                        <li class="nav-item" v-if="isLoggedIn">
                            <a class="nav-link active">Messages</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="about.html">About</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="contact.html">Contact</a>
                        </li>
                    </ul>
                    
                    <div class="auth-block">
                        
                        <template v-if="!isLoggedIn">
                            <a href="login.html" class="btn btn-outline-light btn-sm">
                                <i class="fas fa-sign-in-alt me-1"></i>Sign In
                            </a>
                            <a href="register.html" class="btn btn-outline-light btn-sm">
                                <i class="fas fa-user-plus me-1"></i>Register
                            </a>
                            <div class="dropdown ms-2" v-if="!isLoggedIn || !isBusinessPartner">
                            <button class="btn btn-light btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                <i class="fas fa-building me-1"></i>For Businesses
                            </button>
                            <ul class="dropdown-menu dropdown-menu-end">
                                <li><a class="dropdown-item" href="register_business.html">
                                    <i class="fas fa-store me-2"></i>Register Green Business
                                </a></li>
                                <li><a class="dropdown-item" href="login_business.html">
                                    <i class="fas fa-sign-in-alt me-2"></i>Business Sign In
                                </a></li>
                            </ul>
                        </div>
                        </template>
                        
                        <template v-else>
                            
                            <div class="dropdown">
                                <button class="btn btn-light btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                    <i class="fas fa-user-circle me-1"></i>{{ userName }}
                                </button>
                                <ul class="dropdown-menu dropdown-menu-end">
                                    <li v-if="isBusinessPartner">
                                        <a class="dropdown-item fw-bold" href="partner_dashboard.html">
                                            <i class="fas fa-tachometer-alt me-2"></i>Partner Dashboard
                                        </a>
                                    </li>
                                    <li v-else>
                                        <a class="dropdown-item fw-bold" href="user_account.html">
                                        <i class="fas fa-tachometer-alt me-2"></i>My Dashboard
                                        </a>
                                    </li>
                                    <li><hr class="dropdown-divider"></li>
                                    <li v-if="!isBusinessPartner">
                                        <a class="dropdown-item" href="user_account.html#interests">
                                        <i class="fas fa-heart me-2"></i>My Interests
                                        </a>
                                    </li>
                                    <li v-if="!isBusinessPartner">
                                        <a class="dropdown-item" href="user_account.html#profile">
                                        <i class="fas fa-cog me-2"></i>Settings
                                        </a>
                                    </li>
                                    <li v-if="!isBusinessPartner"><hr class="dropdown-divider"></li>
                                    <li v-if="!isBusinessPartner">
                                        <a class="dropdown-item" href="register_business.html">
                                        <i class="fas fa-plus me-2"></i>List Your Business
                                        </a>
                                    </li>
                                </ul>
                            </div>

                            <button class="btn btn-outline-light btn-sm" @click="logout">
                                <i class="fas fa-sign-out-alt me-1"></i>Logout
                            </button>
                            
                        </template>
                    </div>
                    
                </div>
            </div>
        </nav>

    <div class="messaging-container">
        <template v-if="!isLoggedIn">
            <div class="container text-center py-5">
                <h2 class="mb-4">Please log in to view messages</h2>
                <a href="login.html" class="btn btn-success btn-lg">
                    <i class="fas fa-sign-in-alt me-2"></i>Sign In
                </a>
            </div>
        </template>

        <template v-else-if="isBusinessPartner">
            <div class="container text-center py-5">
                <h2 class="mb-4">Business accounts use a different messaging page</h2>
                <a href="messages_business.html" class="btn btn-success btn-lg">
                    <i class="fas fa-comments me-2"></i>Go to Business Messages
                </a>
            </div>
        </template>

        <template v-else-if="!currentUserId && !loadingConversations">
            <div class="text-center p-5">
                <div class="spinner-border text-success" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-3">Initializing messages...</p>
            </div>
        </template>
        
        <template v-else-if="loadingConversations && currentUserId">
            <div class="text-center p-5">
                <div class="spinner-border text-success" role="status">
                    <span class="visually-hidden">Loading conversations...</span>
                </div>
                <p class="mt-3">Loading conversations...</p>
            </div>
        </template>

        <template v-else-if="currentUserId && !loadingConversations">
            <div class="messaging-wrapper">
                <!-- Conversations Sidebar -->
                <div class="conversations-sidebar" :class="{'hidden': showChat}">
                    <div class="conversations-header">
                        <h3><i class="fas fa-comments me-2"></i>Messages</h3>
                        <div class="search-box">
                            <input 
                                type="text" 
                                class="form-control" 
                                placeholder="Search conversations..."
                                v-model="searchQuery"
                            >
                        </div>
                    </div>
                    
                    <div class="conversations-list">
                        <div v-if="loadingConversations" class="text-center p-4">
                            <div class="spinner-border text-success" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                        <div v-else-if="filteredConversations.length === 0" class="text-center p-4 text-muted">
                            <i class="fas fa-inbox fa-2x mb-2"></i>
                            <p>No conversations yet</p>
                        </div>
                        <div 
                            v-else
                            v-for="conv in filteredConversations" 
                            :key="conv.id"
                            class="conversation-item"
                            :class="{'active': selectedConversation && selectedConversation.id === conv.id}"
                            @click="selectConversation(conv)"
                        >
                            <div class="conversation-avatar">
                                {{ getInitials(conv.businessName) }}
                            </div>
                            <div class="conversation-content">
                                <div class="conversation-top">
                                    <span class="conversation-name">{{ conv.businessName }}</span>
                                    <span class="conversation-time">{{ formatTime(conv.lastMessageTime) }}</span>
                                </div>
                                <div class="conversation-preview">
                                    <span v-if="conv.unread > 0" class="unread-badge">{{ conv.unread }}</span>
                                    {{ conv.lastMessage }}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Chat Area -->
                <div class="chat-area" :class="{'mobile-show': showChat}">
                    <div v-if="!selectedConversation" class="empty-state">
                        <i class="fas fa-comments"></i>
                        <h3>Select a conversation</h3>
                        <p>Choose a business from the list to start messaging</p>
                    </div>

                    <template v-else>
                        <!-- Chat Header -->
                        <div class="chat-header">
                            <div class="chat-header-left">
                                <button class="btn btn-sm d-md-none" @click="backToList">
                                    <i class="fas fa-arrow-left"></i>
                                </button>
                                <div class="chat-avatar">
                                    {{ getInitials(selectedConversation.businessName) }}
                                </div>
                                <div class="chat-info">
                                    <h4>{{ selectedConversation.businessName }}</h4>
                                    <span class="status" :class="{'online': selectedConversation.online}">
                                        {{ selectedConversation.online ? 'Online' : 'Offline' }}
                                    </span>
                                </div>
                            </div>
                            <div class="chat-actions">
                                <button title="View Business Profile" @click="viewBusinessProfile">
                                    <i class="fas fa-info-circle"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Messages Container -->
                        <div class="messages-container" ref="messagesContainer">
                            <div v-if="loadingMessages" class="text-center p-4">
                                <div class="spinner-border text-success" role="status">
                                    <span class="visually-hidden">Loading messages...</span>
                                </div>
                            </div>
                            <template v-else-if="messages.length === 0">
                                <div class="text-center p-5 text-muted">
                                    <i class="fas fa-comments fa-3x mb-3"></i>
                                    <p>No messages yet. Start the conversation!</p>
                                </div>
                            </template>
                            <template v-else>
                                <div v-for="(group, date) in groupedMessages" :key="date">
                                    <div class="message-date">
                                        <span>{{ date }}</span>
                                    </div>
                                    
                                    <div v-for="msg in group" :key="msg.id" class="message" :class="msg.sent ? 'sent' : 'received'">
                                        <div class="message-bubble">
                                            <div class="message-text">{{ msg.text }}</div>
                                            <div class="message-time">{{ msg.time }}</div>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>

                        <!-- Message Input -->
                        <div class="message-input-area">
                            <div class="message-input-wrapper">
                                <textarea 
                                    class="message-input" 
                                    placeholder="Type your message..."
                                    v-model="newMessage"
                                    @keydown.enter.exact.prevent="sendMessage"
                                    @keydown.shift.enter.prevent
                                    rows="1"
                                ></textarea>
                                <button 
                                    class="send-button" 
                                    @click="sendMessage"
                                    :disabled="!newMessage.trim() || sendingMessage || !selectedConversation"
                                    title="Send message"
                                >
                                    <i v-if="!sendingMessage" class="fas fa-paper-plane"></i>
                                    <i v-else class="fas fa-spinner fa-spin"></i>
                                </button>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </template>
        </div>
    </div> <!-- Close #app div -->

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script type="module">
    import { authMixin } from './js/auth-mixin.js';
    // Firebase completely removed - using PHP/MySQL for messaging

    const { createApp } = Vue;

    createApp({
        mixins: [authMixin],
        data() {
            return {
                currentUserId: null,
                searchQuery: '',
                selectedConversation: null,
                newMessage: '',
                showChat: false,
                conversations: [],
                messages: [],
                loadingConversations: true,
                loadingMessages: false,
                sendingMessage: false,
                pollingInterval: null,
                messagesPollingInterval: null,
                lastMessageId: null
            };
        },
        computed: {
            filteredConversations() {
                if (!this.searchQuery) return this.conversations;
                return this.conversations.filter(conv => 
                    conv.businessName.toLowerCase().includes(this.searchQuery.toLowerCase())
                );
            },
            groupedMessages() {
                if (this.messages.length === 0) return {};
                
                const groups = {};
                this.messages.forEach(msg => {
                    const date = this.formatDate(msg.timestamp);
                    if (!groups[date]) {
                        groups[date] = [];
                    }
                    groups[date].push(msg);
                });
                return groups;
            }
            // Note: isBusinessPartner is already defined in authMixin, no need to redefine it
        },
        watch: {
            isLoggedIn(newVal) {
                if (newVal) {
                    // Wait for auth to fully initialize
                    this.$nextTick(() => {
                        if (this.userId) {
                            this.currentUserId = this.userId.toString();
                            this.loadUserData(this.userId);
                            
                            // Check for business_id in URL and store in sessionStorage
                            const urlParams = new URLSearchParams(window.location.search);
                            const businessId = urlParams.get('business_id');
                            if (businessId) {
                                sessionStorage.setItem('openConversation', businessId);
                            }
                            
                    this.loadConversations(true);
                } else {
                            // Wait a bit for userId to be available
                            setTimeout(() => {
                                if (this.userId) {
                                    this.currentUserId = this.userId.toString();
                                    this.loadUserData(this.userId);
                                    
                                    const urlParams = new URLSearchParams(window.location.search);
                                    const businessId = urlParams.get('business_id');
                                    if (businessId) {
                                        sessionStorage.setItem('openConversation', businessId);
                                    }
                                    
                                    this.loadConversations(true);
                                }
                            }, 500);
                        }
                    });
                } else {
                    this.currentUserId = null;
                }
            }
        },
        async mounted() {
            // Check for business_id in URL and store in sessionStorage
            const urlParams = new URLSearchParams(window.location.search);
            const businessId = urlParams.get('business_id');
            if (businessId) {
                console.log('Business ID found in URL:', businessId);
                sessionStorage.setItem('openConversation', businessId);
            }
            
            // Auth state is handled by authMixin
            // Wait for auth to initialize with retry mechanism
            this.$nextTick(() => {
                const checkAuthAndLoad = () => {
                    if (this.isLoggedIn && this.userId) {
                        // Use MySQL user_id instead of Firebase UID
                        this.currentUserId = this.userId.toString(); // Convert to string for compatibility
                        this.loadUserData(this.userId);
                        this.loadConversations(true);
                        console.log('Auth ready, loading conversations. Business ID to open:', businessId);
                    } else {
                        // Keep checking every 200ms for up to 5 seconds
                        let attempts = 0;
                        const maxAttempts = 25;
                        const checkInterval = setInterval(() => {
                            attempts++;
                            if (this.isLoggedIn && this.userId) {
                                clearInterval(checkInterval);
                                this.currentUserId = this.userId.toString();
                                this.loadUserData(this.userId);
                                this.loadConversations(true);
                                console.log('Auth ready after retry, loading conversations');
                            } else if (attempts >= maxAttempts) {
                                clearInterval(checkInterval);
                                if (businessId) {
                                    console.log('Auth not ready after max attempts, but business_id is set:', businessId);
                                }
                            }
                        }, 200);
                    }
                };
                
                setTimeout(checkAuthAndLoad, 500);
            });
        },
        methods: {
            async loadUserData(userId) {
                // Use MySQL to get user data instead of Firestore
                try {
                    const resp = await fetch(`api/data.php?action=get_user_name&user_id=${userId}`, {
                        credentials: 'include'
                    });
                    if (resp.ok) {
                        const data = await resp.json();
                        if (data.success && data.name) {
                            this.userName = data.name;
                        return;
                    }
                    }
                } catch (error) {
                    console.error('Error loading user data from MySQL:', error);
                }
                
            },
            async loadConversations(showLoading = false) {
                if (!this.currentUserId) return;
                
                // Only show loading spinner on initial load, not during polling
                if (showLoading) {
                this.loadingConversations = true;
                }
                
                try {
                    const response = await fetch('api/messages.php?action=conversations', {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    if (!response.ok) {
                        if (response.status === 401) {
                            alert('Session expired. Please log in again.');
                            window.location.href = 'login.html';
                        return;
                        }
                        throw new Error('Failed to load conversations');
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        const newConversations = data.conversations.map(conv => {
                            // Fix timestamp year before storing
                            let lastMessageTime = conv.last_message_time || null;
                            if (lastMessageTime && typeof lastMessageTime === 'string' && lastMessageTime.startsWith('2025-')) {
                                lastMessageTime = lastMessageTime.replace('2025-', '2024-');
                            }
                            
                            return {
                                id: conv.id,
                                businessId: conv.business_id,
                                businessName: conv.business_name || 'Business',
                                lastMessage: conv.last_message || '',
                                lastMessageTime: lastMessageTime,
                                unread: conv.unread_count || 0
                            };
                        });
                        
                        // Create a map of existing conversations by ID for efficient lookup
                        const existingMap = new Map();
                        this.conversations.forEach(conv => {
                            existingMap.set(conv.id, conv);
                        });
                        
                        // Check if conversations actually changed by comparing by ID
                        let hasChanged = false;
                        const newMap = new Map();
                        newConversations.forEach(newConv => {
                            newMap.set(newConv.id, newConv);
                            const oldConv = existingMap.get(newConv.id);
                            if (!oldConv || 
                                oldConv.lastMessage !== newConv.lastMessage ||
                                oldConv.lastMessageTime !== newConv.lastMessageTime ||
                                oldConv.unread !== newConv.unread ||
                                oldConv.businessName !== newConv.businessName) {
                                hasChanged = true;
                            }
                        });
                        
                        // Check if any conversations were removed
                        if (this.conversations.length !== newConversations.length) {
                            hasChanged = true;
                        }
                        
                        // Only update if something changed
                        if (hasChanged || this.conversations.length === 0) {
                            // Update existing conversations in place to preserve Vue reactivity
                            if (this.conversations.length > 0) {
                                newConversations.forEach(newConv => {
                                    const existing = existingMap.get(newConv.id);
                                    if (existing) {
                                        // Update in place
                                        existing.lastMessage = newConv.lastMessage;
                                        existing.lastMessageTime = newConv.lastMessageTime;
                                        existing.unread = newConv.unread;
                                        existing.businessName = newConv.businessName;
                                    } else {
                                        // New conversation - add it
                                        this.conversations.push(newConv);
                                    }
                                });
                                
                                // Remove conversations that no longer exist
                                this.conversations = this.conversations.filter(conv => newMap.has(conv.id));
                            } else {
                                // First load - just set the array
                                this.conversations = newConversations;
                            }
                            
                            // Sort by last message time (newest first)
                            this.conversations.sort((a, b) => {
                                const timeA = a.lastMessageTime ? new Date(a.lastMessageTime.replace('2025-', '2024-')) : new Date(0);
                                const timeB = b.lastMessageTime ? new Date(b.lastMessageTime.replace('2025-', '2024-')) : new Date(0);
                                return timeB.getTime() - timeA.getTime();
                            });
                        }
                        
                        this.loadingConversations = false;
                        if (this.conversations.length > 0 && !this.selectedConversation) {
                        this.autoOpenConversation();
                        }
                        
                        // Start polling for new conversations (only if not already polling)
                        if (!this.pollingInterval) {
                            this.pollingInterval = setInterval(() => this.loadConversations(false), 5000); // Poll every 5 seconds without loading spinner
                        }
                                } else {
                        throw new Error(data.error || 'Failed to load conversations');
                    }
                } catch (error) {
                    console.error('Error loading conversations:', error);
                    this.loadingConversations = false;
                    this.conversations = [];
                }
            },

            async getBusinessName(businessId) {
                try {
                    // Get from MySQL database using business_id (from businesses table)
                    const response = await fetch(`api/data.php?action=get_business_name&business_id=${businessId}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.name) {
                            return data.name;
                        }
                    }
                } catch (error) {
                    console.error('Error getting business name:', error);
                }
                return 'Business';
            },
            async selectConversation(conv) {
                console.log('Selecting conversation:', conv);
                this.selectedConversation = conv;
                conv.unread = 0;
                this.showChat = true;
                
                // Load messages for this conversation
                if (conv.id) {
                this.loadMessages(conv.id);
                } else {
                    console.error('Conversation has no ID:', conv);
                }
                
                this.$nextTick(() => {
                    this.scrollToBottom();
                });
            },
            async loadMessages(conversationId) {
                if (!conversationId) return;
                
                this.loadingMessages = true;
                this.messages = [];
                
                // Stop previous polling
                if (this.messagesPollingInterval) {
                    clearInterval(this.messagesPollingInterval);
                }
                
                try {
                    const response = await fetch(`api/messages.php?action=messages&conversation_id=${conversationId}`, {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to load messages');
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Get current user ID for determining sent/received
                    const sessionResp = await fetch('api/bridge.php?action=get_user', {
                        credentials: 'include'
                    });
                    let sessionData = null;
                    if (sessionResp.ok) {
                        sessionData = await sessionResp.json();
                    }
                        const currentUserId = sessionData?.success ? sessionData.user.userId : null;
                        
                        this.messages = data.messages.map(msg => {
                            // Fix timestamp year before creating Date object
                            let timestampStr = msg.timestamp;
                            if (typeof timestampStr === 'string' && timestampStr.startsWith('2025-')) {
                                timestampStr = timestampStr.replace('2025-', '2024-');
                            }
                            
                            return {
                                id: msg.id,
                                text: msg.text,
                                senderId: msg.sender_id,
                                senderName: msg.sender_name,
                                sent: currentUserId && msg.sender_id == currentUserId,
                                timestamp: new Date(timestampStr),
                                time: this.formatTime(timestampStr)
                            };
                        });
                        
                        this.lastMessageId = this.messages.length > 0 ? this.messages[this.messages.length - 1].id : null;
                        this.loadingMessages = false;
                        
                        this.$nextTick(() => {
                            this.scrollToBottom();
                        });
                        
                        // Start polling for new messages
                        this.messagesPollingInterval = setInterval(() => {
                            this.pollMessages(conversationId);
                        }, 3000); // Poll every 3 seconds
                    } else {
                        throw new Error(data.error || 'Failed to load messages');
                    }
                } catch (error) {
                    console.error('Error loading messages:', error);
                    this.loadingMessages = false;
                }
            },
            
            async pollMessages(conversationId) {
                try {
                    const response = await fetch(`api/messages.php?action=messages&conversation_id=${conversationId}`, {
                        method: 'GET',
                    credentials: 'include'
                });
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        if (data.success && data.messages.length > 0) {
                            // Check if there are new messages
                            const lastMsg = data.messages[data.messages.length - 1];
                            if (lastMsg.id !== this.lastMessageId) {
                                // Reload all messages
                                this.loadMessages(conversationId);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error polling messages:', error);
                }
            },
            async sendMessage() {
                if (!this.newMessage.trim() || !this.selectedConversation || this.sendingMessage) return;
                
                this.sendingMessage = true;
                
                try {
                    const conversationId = this.selectedConversation.id;
                    const messageText = this.newMessage.trim();
                    
                    const response = await fetch('api/messages.php?action=send', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            conversation_id: conversationId,
                            text: messageText
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to send message');
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        if (data.message) {
                            // Fix timestamp year before creating Date object
                            let timestampStr = data.message.timestamp;
                            if (typeof timestampStr === 'string' && timestampStr.startsWith('2025-')) {
                                timestampStr = timestampStr.replace('2025-', '2024-');
                            }
                            
                            // Add message to local array immediately for instant feedback
                            const newMsg = {
                                id: data.message.id,
                                text: data.message.text,
                                senderId: data.message.sender_id,
                                senderName: data.message.sender_name,
                                sent: true,
                                timestamp: new Date(timestampStr),
                                time: this.formatTime(timestampStr)
                            };
                            this.messages.push(newMsg);
                            this.lastMessageId = newMsg.id;
                        }
                        
                        // Update conversation list without reloading (to avoid scroll jump and flickering)
                        if (this.selectedConversation && this.selectedConversation.id === data.conversation_id) {
                            // Update last message in current conversation
                            this.selectedConversation.lastMessage = data.message?.text || '';
                            // Fix timestamp year before storing
                            let timestamp = data.message?.timestamp || '';
                            if (timestamp && typeof timestamp === 'string' && timestamp.startsWith('2025-')) {
                                timestamp = timestamp.replace('2025-', '2024-');
                            }
                            this.selectedConversation.lastMessageTime = timestamp;
                            
                            // Update unread count if it's a received message
                            if (data.message && !data.message.sent) {
                                this.selectedConversation.unread = (this.selectedConversation.unread || 0) + 1;
                            }
                        }
                        
                        // Don't reload conversations immediately - let the polling handle it to avoid flickering
                    
                    this.newMessage = '';
                    // Use setTimeout to ensure DOM is updated before scrolling
                    setTimeout(() => {
                        this.scrollToBottom();
                    }, 100);
                    } else {
                        throw new Error(data.error || 'Failed to send message');
                    }
                } catch (error) {
                    console.error('Error sending message:', error);
                    alert('Error sending message: ' + (error.message || 'Please try again.'));
                } finally {
                    this.sendingMessage = false;
                }
            },
            async createConversation(businessId) {
                if (!businessId) return;
                
                try {
                    // Send a message to create the conversation (API will handle creation if it doesn't exist)
                    const response = await fetch('api/messages.php?action=send', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                    body: JSON.stringify({
                        business_id: businessId,
                        text: 'Hi' // Initial message to create conversation
                    })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success) {
                            return data.conversation_id;
                        }
                    }
                    
                    throw new Error('Failed to create conversation');
                } catch (error) {
                    console.error('Error creating conversation:', error);
                    throw error;
                }
            },
            
            beforeUnmount() {
                // Clean up polling intervals
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                }
                if (this.messagesPollingInterval) {
                    clearInterval(this.messagesPollingInterval);
                }
            },
            backToList() {
                this.showChat = false;
            },
            viewBusinessProfile() {
                if (this.selectedConversation && this.selectedConversation.businessId) {
                    window.location.href = `business_profile.html?id=${this.selectedConversation.businessId}`;
                }
            },
            scrollToBottom() {
                this.$nextTick(() => {
                    setTimeout(() => {
                const container = this.$refs.messagesContainer;
                if (container) {
                            // Use scrollTop for reliable scrolling
                    container.scrollTop = container.scrollHeight;
                }
                    }, 50);
                });
            },
            getInitials(name) {
                if (!name) return '?';
                const parts = name.split(' ');
                if (parts.length > 1) {
                    return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                }
                return name[0].toUpperCase();
            },
            formatTime(date) {
                if (!date) return '';
                
                // Handle MySQL datetime strings (e.g., "2024-01-15 10:30:00") or Date objects
                let d;
                let originalInput = date;
                
                if (typeof date === 'string') {
                    // MySQL datetime format: "YYYY-MM-DD HH:MM:SS"
                    let normalized = date.trim();
                    
                    // Check if date is in 2025 when we're in 2024 - auto-fix year
                    const currentYear = new Date().getFullYear();
                    if (currentYear === 2024 || currentYear === 2025) {
                        // If timestamp starts with 2025, replace with 2024
                        if (normalized.startsWith('2025-')) {
                            normalized = normalized.replace('2025-', '2024-');
                            console.log('Auto-corrected year from 2025 to 2024:', date, '->', normalized);
                        }
                    }
                    
                    if (normalized.includes(' ') && !normalized.includes('T')) {
                        // Replace space with T for ISO parsing (local time)
                        normalized = normalized.replace(' ', 'T');
                    }
                    d = new Date(normalized);
                } else if (date instanceof Date) {
                    d = new Date(date); // Create a copy to avoid mutating original
                    // Check if date is in 2025 when current year is 2024
                    const currentYear = new Date().getFullYear();
                    if (d.getFullYear() === 2025 && (currentYear === 2024 || currentYear === 2025)) {
                        // Adjust year back by 1
                        d.setFullYear(d.getFullYear() - 1);
                        console.log('Auto-corrected Date object year from 2025 to 2024, original:', date);
                    }
                } else {
                    d = new Date(date);
                }
                
                // Check if date is valid
                if (isNaN(d.getTime())) {
                    console.error('Invalid timestamp:', date);
                    return '';
                }
                
                const now = new Date();
                const diffMs = now.getTime() - d.getTime();
                let diff = Math.floor(diffMs / 1000);
                
                // Handle future dates (might be due to timezone issues or wrong dates)
                if (diff < 0) {
                    // If date is in the future, check if it's a year off (common DB issue)
                    const yearDiff = now.getFullYear() - d.getFullYear();
                    // If date is exactly 1 year ahead (yearDiff === -1), adjust it
                    if (yearDiff === -1 && Math.abs(diff) < 400 * 24 * 3600) { // Within ~400 days
                        // Likely a year off - adjust by subtracting a year
                        d.setFullYear(d.getFullYear() - 1);
                        diff = Math.floor((now.getTime() - d.getTime()) / 1000);
                        console.log('Adjusted future date year, new diff:', diff, 'seconds');
                    } else {
                        console.log('Future date detected, showing Just now. Original:', originalInput, 'Parsed:', d, 'Diff:', diff);
                        return 'Just now'; // Future dates show as "Just now"
                    }
                }
                
                if (diff < 0) return 'Just now';
                if (diff < 60) return 'Just now';
                
                // Get today and yesterday dates using local time
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                // Get message date at midnight for comparison
                const msgDate = new Date(d);
                msgDate.setHours(0, 0, 0, 0);
                
                // Debug: log the comparison
                const isToday = msgDate.getTime() === today.getTime();
                const isYesterday = msgDate.getTime() === yesterday.getTime();
                
                // Check if same day
                if (isToday) {
                    if (diff < 3600) {
                        // Less than 1 hour: show "X min ago"
                        const mins = Math.floor(diff / 60);
                        return mins === 1 ? '1 min ago' : mins + ' min ago';
                    } else {
                        // Same day but > 1 hour: show time like "15:00"
                        return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                    }
                }
                
                // Check if yesterday
                if (isYesterday) {
                    return 'Yesterday ' + d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                }
                
                // For older messages (not today or yesterday)
                if (diff < 604800) {
                    // Within a week: show days ago
                    const days = Math.floor(diff / 86400);
                    if (days === 0) {
                        // Same day but might have failed date comparison due to timezone - show time
                        return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                    } else if (days === 1) {
                        return 'Yesterday';
                    } else {
                        return days + ' days ago';
                    }
                }
                
                // Older than a week: show date
                return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            },
            formatDate(date) {
                if (!date) return '';
                
                // Handle MySQL datetime strings
                let d;
                if (typeof date === 'string') {
                    let normalized = date.trim();
                    if (normalized.includes(' ') && !normalized.includes('T')) {
                        normalized = normalized.replace(' ', 'T');
                    }
                    d = new Date(normalized);
                } else if (date instanceof Date) {
                    d = date;
                } else {
                    d = new Date(date);
                }
                
                // Check if date is valid
                if (isNaN(d.getTime())) {
                    return '';
                }
                
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                if (d.toDateString() === today.toDateString()) return 'Today';
                if (d.toDateString() === yesterday.toDateString()) return 'Yesterday';
                return d.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
            },
            async autoOpenConversation() {
                const businessIdToOpen = sessionStorage.getItem('openConversation');
                if (businessIdToOpen && this.currentUserId) {
                    console.log('Auto-opening conversation for business ID:', businessIdToOpen);
                    sessionStorage.removeItem('openConversation');
                    
                    try {
                        const businessId = parseInt(businessIdToOpen);
                        
                        // Find conversation by business_id (from businesses table)
                        let conversation = this.conversations.find(c => c.businessId == businessId);
                        
                        if (!conversation) {
                            console.log('No existing conversation found, creating new one...');
                            
                            // Get business name FIRST before creating conversation
                            const response = await fetch(`api/data.php?action=get_business_name&business_id=${businessId}`, {
                            credentials: 'include'
                        });
                            let businessName = 'Business';
                            if (response.ok) {
                                const data = await response.json();
                                if (data.success && data.name) {
                                    businessName = data.name;
                                }
                            }
                            
                            // Create conversation using the business_id
                            const conversationId = await this.createConversation(businessId);
                            console.log('Created conversation ID:', conversationId);
                            
                            conversation = {
                                id: conversationId,
                                businessId: businessId,
                                businessName: businessName,
                                lastMessage: '',
                                lastMessageTime: new Date(),
                                unread: 0
                            };
                            this.conversations.unshift(conversation);
                            console.log('Added new conversation to list:', conversation);
                        }
                        
                        console.log('Selecting conversation:', conversation);
                        this.selectConversation(conversation);
                    } catch (error) {
                        console.error('Error auto-opening conversation:', error);
                        alert('Error opening conversation: ' + (error.message || 'Please try again.'));
                    }
                }
            },
        },
        watch: {
            isLoggedIn(newVal) {
                // When user logs in, check if we need to auto-open conversation
                if (newVal && this.currentUserId) {
                    const businessIdToOpen = sessionStorage.getItem('openConversation');
                    if (businessIdToOpen) {
                        console.log('User logged in, will auto-open conversation for:', businessIdToOpen);
                        // Wait a bit for conversations to load, then try to open
                        setTimeout(() => {
                            this.autoOpenConversation();
                        }, 1000);
                    }
                }
            },
            conversations: {
                handler(newVal, oldVal) {
                    // Only auto-open if we have conversations and there's a business_id to open
                    const businessIdToOpen = sessionStorage.getItem('openConversation');
                    if (businessIdToOpen && newVal.length > 0 && this.currentUserId && this.isLoggedIn) {
                        console.log('Conversations loaded, auto-opening conversation for:', businessIdToOpen);
                        this.$nextTick(() => {
                            this.autoOpenConversation();
                        });
                    }
                },
                immediate: false
            },
            loadingConversations(newVal) {
                // When conversations finish loading (whether empty or not), check if we need to auto-open
                if (!newVal && this.isLoggedIn && this.currentUserId) {
                    const businessIdToOpen = sessionStorage.getItem('openConversation');
                    if (businessIdToOpen) {
                        console.log('Conversations finished loading, will try to auto-open conversation for:', businessIdToOpen);
                        // Wait a bit for everything to settle, then auto-open
                        setTimeout(() => {
                            this.autoOpenConversation();
                        }, 800);
                    }
                }
            },
            currentUserId(newVal) {
                // When currentUserId is set, check if we need to auto-open
                if (newVal && this.isLoggedIn) {
                    const businessIdToOpen = sessionStorage.getItem('openConversation');
                    if (businessIdToOpen) {
                        console.log('Current user ID set, will auto-open conversation for:', businessIdToOpen);
                        setTimeout(() => {
                            this.autoOpenConversation();
                        }, 1000);
                    }
                }
            }
        }
    }).mount('#app');
</script>
<script>
    // Set active nav link based on current page
    document.addEventListener('DOMContentLoaded', function() {
        const currentPage = window.location.pathname.split('/').pop() || 'index.html';
        const navLinks = document.querySelectorAll('.navbar-nav .nav-link');
        
        navLinks.forEach(link => {
            link.classList.remove('active');
            const linkHref = link.getAttribute('href');
            if (linkHref && (linkHref === currentPage || (currentPage === '' && linkHref === 'index.html'))) {
                link.classList.add('active');
            }
        });
    });
</script>
</body>
</html>
